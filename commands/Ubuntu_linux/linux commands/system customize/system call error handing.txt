# 시스템 호출과 라이브러리 함수
- 리눅스에서 사용하는 일반적인 명령(command)에 대한 설명: 섹션 1
- 시스템 호출(system call): 섹션 2
- 라이브러리 함수(library function): 섹션 3

man 페이지의 섹션 번호 : $ man uname // UNAME(1)
섹션 2의 설명을 보려면? ex. $ man -s 2 uname // UNAME(2) 



## 시스템 호출의 오류 처리
- 리눅스는 asm-generic/errno-base.h 파일에 정의되어 있고 유닉스는 sys/errno.h 파일에 정의

# asm-generic/errno-base.h 예시
1   #define EPERM   1   /*Operation not permitted*/
2   #define ENOENT  2   /*No such file or directory*/
3   #define ENOEXEC 12  /*Out of memory*/
4   #define EBADF   13  /*Permission denied*/



- errno; 변수는 해당 시스템 호출에서 발생한 오류가 무엇인지 알려줌
-------------------------------------------------
01 #include <stdio.h>
02 #include <unistd.h>
03 #include <errno.h>
04
05 extern int errno;
06
07 int main() {
08  if(access("test.txt", F_OK) == -1) { //access()함수는 접근권환 관련
09      printf("errno=%d\n", errno);
10  }
11 }


$ ./ch1_1.out
errno=2
-------------------------------------------------
$ man access 명령으로 access() 함수에서 발생하는 오류코드와 해당 설명을 확인


### 오류 메시지 출력 : perror(3)
-------------------------------------------------
# include <stdio.h>             [함수 원형]

void perror(const char*s);
-------------------------------------------------
01 #include <stdio.h>
02 #include <unistd.h>
03 #include <errno.h>
04 #include <stdlib.h>
05
06 int main() {
07  if(access("test.txt", R_OK) == -1) {
08      perror("test.txt");
09      exit(1);
10  }
11 }

$ ch1_4.out
test.txt: No such file or directory
-------------------------------------------------
- perror() 함수는 오류 메시지 출력만 하므로 오류의 결과로 프로그램을 종료해야 한다면 exit() 함수를 호출해야 함
- 오류파일의 이름을 출력한다.


### 오류 메시지 출력 : strerror(3)
-------------------------------------------------
#include <string.h>             [함수 원형]
char *strerror(int errnum);
-------------------------------------------------
01 #include <stdio.h>
02 #include <unistd.h>
03 #include <errno.h>
04 #include <stdlib.h>
05 #include <string.h>
06
07 extern int errno;
08
09 int main() {
10  char *err;
11
12  if(access("test.txt", R_OK) == -1) {
13      err = strerror(errno);
14      printf("오류: %s(test.txt)\n", err);
15      exit(1);
16  }
17 }

$ ch1_4.out
오류: No such file or directory{test.txt}
-------------------------------------------------
-  13행에서 리턴한 문자열을 적절한 형태로 가공해 오류 메시지를 출력

- ENOENT: 파일이나 디렉터리가 존재하지 않음 (파일이 없을 때 발생)
- EACCES: 파일에 대한 접근 권한이 없음 (파일에 접근할 권한이 없을 때 발생)


## 시스템 도구

// 포인터의 크기: 8byte // 64-bit운영체제

메모리 할당: malloc(3)
-------------------------------------------------
#include <stdlib.h>                 [함수 원형]
void *malloc(size_t size);
- size : 할당받을 메모리 크기
-------------------------------------------------
char *ptr
ptr = malloc(sizeof(char) * 100); 
// 문자(char) 100개 저장할 수 있는 메모리 할당
-------------------------------------------------


메모리 할당: calloc(3)
-------------------------------------------------
#include <stdlib.h>                 [함수 원형]
void *calloc(size_t nmemb, size_t size);
- nmemb : 배열 요소의 개수
- size : 할당받을 메모리 크기
-------------------------------------------------
char *ptr 
ptr = calloc(10, 20);
// 요소가 10개이고 각 요소의 크기가 20바이트인 배열을 저장할 수 있는 메모리를 할당
-------------------------------------------------


메모리 할당: realloc(3)
-------------------------------------------------
#include <stdlib.h>                 [함수 원형]
void *realloc(void *ptr, size_t size);
- ptr : 할당받은 메모리를 가리키는 포인터
- size : 할당받을 메모리 크기
-------------------------------------------------
char *ptr, *new;
ptr = malloc(sizeof(char) * 100);
new = realloc(ptr, 100);
// malloc() 함수로 할당받은 메모리에 추가로 100바이트를 할당
-------------------------------------------------


메모리 해제 : free(3)
-------------------------------------------------
#include <stdlib.h>         [함수 원형]
void free(void *ptr);
- ptr : 해제할 메모리 주소
-------------------------------------------------



## 예외처리 방법

1. 반환 값 검사: 예외가 발생할 수 있는 코드에 대해 직접 오류를 반환하거나 상태 값을 반환하여 처리하는 방법입니다. C 언어와 같은 언어에서 주로 사용됩니다.

if문으로 처리
-------------------------------------------------
int divide(int a, int b) {
    if (b == 0) {
        return -1;  // 오류 발생시 반환 값
    }
    return a / b;
}

int main() {
    int result = divide(10, 0);
    if (result == -1) {
        printf("오류: 0으로 나눌 수 없습니다.\n");
    } else {
        printf("결과: %d\n", result);
    }
    return 0;
}
-------------------------------------------------



2. 예외 객체를 직접 던지기 (throw): Java, C#, Python 등에서는 예외를 발생시키는 throw 문을 사용하여 예외를 처리할 수 있습니다.
 이때 예외가 발생한 곳에서 catch로 처리하지 않으면 호출한 쪽에서 처리해야 합니다.

throw문, try-catch문으로 처리
-------------------------------------------------
public class Example {
    public static void checkNumber(int number) {
        if (number == 0) {
            throw new ArithmeticException("0으로 나눌 수 없습니다.");
        }
    }

    public static void main(String[] args) {
        try {
            checkNumber(0);
        } catch (ArithmeticException e) {
            System.out.println(e.getMessage());
        }
    }
}
-------------------------------------------------



3. finally만 사용할 경우: 일부 언어에서는 finally 블록만 사용할 수 있습니다.
 finally는 예외 처리와 관계없이 항상 실행되는 코드로, 자원 해제나 종료 작업 등에 유용합니다.

finally문으로 처리
-------------------------------------------------
try {
    // 예외가 발생할 가능성이 있는 코드
} finally {
    // 예외가 발생하든 안 하든 항상 실행되는 코드
    System.out.println("항상 실행");
}
-------------------------------------------------


### throw의 사용 규칙

1. throw 뒤에는 예외 객체를 일반적으로 던집니다. 예외는 값을 던지거나 객체를 던질 수 있습니다.
2. throw는 반드시 try-catch와 함께 사용되어야 합니다. 예외가 던져지면 catch 블록에서 이를 처리해야 프로그램이 비정상적으로 종료되지 않습니다.

- throw와 noexcept
: 함수가 예외를 던지지 않는다는 것을 명시적으로 선언할 수 있습니다. 이를 사용하면, 해당 함수에서 예외가 발생하지 않는다고 보장하며, 컴파일러 최적화나 코드 이해를 돕는 데 유용합니다.
-------------------------------------------------
void safeFunction() noexcept {
    cout << "이 함수는 예외를 던지지 않습니다." << endl;
}

void riskyFunction() {
    throw "Error occurred";  // 예외 발생
}
-------------------------------------------------



### Python 예외처리
try-except 문
-------------------------------------------------
try:
    num = int(input("숫자를 입력하세요: "))
    print(10 / num)
except ValueError:
    print("입력한 값이 숫자가 아닙니다.")
except ZeroDivisionError:
    print("0으로 나눌 수 없습니다.")
else:
    print("계산이 정상적으로 완료되었습니다.")
finally:
    print("프로그램이 종료되었습니다.")
-------------------------------------------------


### C++, C#
try-catch 문
-------------------------------------------------
try {
    // 예외가 발생할 가능성이 있는 코드
    int result = 10 / 0;
} catch (DivideByZeroException e) {
    Console.WriteLine("0으로 나눌 수 없습니다.");
} finally {
    Console.WriteLine("항상 실행되는 코드");
}
-------------------------------------------------


### JavaScript
try-catch 문
-------------------------------------------------
try {
    // 예외가 발생할 가능성이 있는 코드
    let result = 10 / 0;
} catch (e) {
    console.log("오류 발생: " + e.message);
} finally {
    console.log("항상 실행되는 코드");
}
-------------------------------------------------



### **`try-catch` 문을 사용하기에 추천하는 코드 유형**

1. 입출력 (I/O) 관련 코드:  파일이 존재하지 않거나 읽을 수 없는 상태, 네트워크 연결이 끊어졌을 때 등 여러 가지 예외적인 상황이 발생할 수 있습니다.

2. 메모리 할당 관련 코드: 동적 메모리 할당(new 또는 malloc 등)은 실패할 수 있기 때문에 메모리 부족과 같은 상황을 처리하기 위해 try-catch를 사용할 수 있습니다.
                        // 동적 메모리 할당에서 bad_alloc 예외가 발생할 수 있으며, 이를 catch 블록에서 처리

3. 네트워크 통신: 네트워크 연결 중에는 연결 실패, 데이터 전송 실패 등 여러 가지 예외가 발생할 수 있습니다.

4. 사용자 입력 검증: 사용자가 입력한 값이 유효하지 않거나 예상 외의 값일 경우 예외를 던져 처리할 수 있습니다.
                    // cin에서 숫자가 아닌 값을 입력받을 경우 예외를 던져 처리합니다.

5. 타사 라이브러리나 API 호출: 외부 라이브러리나 API를 호출할 때도 예외가 발생할 수 있습니다. 
                            // 예를 들어, 데이터베이스 연결, 외부 API 호출 등에서는 네트워크 장애, 타임아웃, 잘못된 응답 등이 발생할 수 있습니다.
                            // 외부 시스템과의 연동은 항상 예외가 발생할 가능성이 있기 때문에 예외 처리 구문이 필수적입니다.

6. 수학적 연산에서 예외 처리: 특히 0으로 나누기와 같은 수학적 연산에서 예외가 발생할 수 있습니다.




## 예외처리 비교

### **장단점 비교**

| **특징**         | **`if`문을 이용한 예외 처리**                                         | **`try-catch`를 이용한 예외 처리**                                                 |
|------------------|----------------------------------------------------------------------|----------------------------------------------------------------------------------|
| **적합한 상황**  | 예상 가능한 오류 처리 (예: 0으로 나누기, 범위 검사 등)                  | 예기치 않은 예외나 예외적인 상황 처리 (예: 메모리 부족, 네트워크 오류)               |
| **가독성**       | 간단하고 직관적. 그러나 많은 오류 처리가 필요할 경우 코드 중복 발생 가능 | 예외를 별도로 처리할 수 있어 흐름이 명확하지만, 예외가 많으면 코드가 복잡해질 수 있음 |
| **성능**         | 성능에 큰 영향을 미치지 않음. 사전 검사만 하므로 빠름                   | 예외가 발생하지 않으면 무시되지만, 예외 발생 시 성능에 부담이 있을 수 있음           |
| **제어 흐름**    | 코드 흐름을 끊지 않고, 사전 처리로 오류를 방지                          | 예외가 발생하면 흐름이 변경되며, `catch`에서 오류 처리                              |
| **에러 추적**    | 오류 발생 시 위치 추적 어려움, `return` 값으로 처리 가능                | 오류의 위치와 메시지를 통해 원인 추적 용이                                         |
| **사용 예시**    | 입력 값 검증, 나누기 연산에서 0 체크 등                                 | 외부 API 호출, 네트워크 오류, 동적 메모리 할당 실패 등                             |

---

1. if문을 사용할 때:

- 예상 가능한 오류에 대해 미리 검사하고 처리할 때.

- 입력 값 검증, 범위 체크, 단순한 오류 처리 등에서 유용합니다.

- 예외가 발생할 가능성이 낮고, "성능이 중요한 경우 적합"합니다.

2. try-catch를 사용할 때:

- 예상치 못한 오류나 예외적인 상황을 처리할 때.

- "외부 시스템과 상호작용하는 코드" (예: 파일 입출력, 네트워크 통신)에서 유용합니다.

- 예외가 발생할 가능성이 높고, 그 예외를 별도로 처리하는 것이 필요한 경우 사용합니다.


---

### 차이점

1. 예외 처리 방식

- if문: 예외 상황을 사전에 확인하고 그에 맞는 처리를 합니다.
    조건문을 사용해 예상되는 문제를 미리 검사하고, 오류를 방지하거나 처리하는 방식입니다.

    - 주로 예상 가능한 오류나 사전 검증이 필요한 상황에 사용됩니다.

- try-catch: 예외가 발생한 후 이를 포착하여 처리하는 방식입니다. 예외가 발생했을 때 흐름을 변경하고, 예외 처리 구문으로 이동하여 오류를 다룹니다.

    - 예기치 않은 오류나 예상하지 못한 예외에 대해 처리할 때 적합합니다.


2. 예상 여부

- if문: 예상 가능한 오류를 처리하는 데 적합합니다. 
    예를 들어, 0으로 나누는 오류나 파일 경로가 존재하는지 확인하는 등의 오류를 처리할 때 유용합니다.

- try-catch: 예상하지 못한 예외나 예외적인 상황에 대한 처리에 유용합니다. 
    예를 들어, 메모리 할당 실패, 네트워크 오류 등 예상하지 못한 예외를 처리할 때 주로 사용됩니다.


3. 가독성

- if문: 조건문을 통해 직접 처리하기 때문에 코드 흐름을 이해하기 쉽고, 예외를 발생시키지 않기 때문에 코드가 단순합니다. 그러나 복잡한 예외 처리 로직을 여러 군데에 분산시킬 수 있으며, 중복된 코드가 발생할 수 있습니다.

- try-catch: 예외를 별도의 블록에서 처리하므로 코드 흐름이 더 명확하고, 예외 발생 시의 흐름을 별도로 관리할 수 있습니다. 다만, 예외가 자주 발생하면 코드가 복잡해질 수 있습니다.


4. 제어 흐름

- if문: 오류가 발생할 수 있는 상황을 미리 방지합니다. 
    예외를 던지는 것이 아니라 검사 후 처리하는 방식이므로 코드의 흐름이 끊기지 않습니다.

- try-catch: 예외가 발생하면 흐름을 변경하여 catch 블록으로 이동하게 되므로, 흐름의 제어가 끊깁니다. 
    이는 예외가 발생하지 않으면 원래 흐름으로 돌아오지만, 예외가 발생한 경우에는 다른 경로로 진행됩니다.


5. 성능

- if문: 조건문을 사용하여 오류를 사전에 검사하므로 성능 상 문제가 거의 없습니다. 
    예외 처리를 하지 않기 때문에 성능에 부담이 적습니다.

- try-catch: 예외가 발생하지 않는 경우, 예외 처리 구문이 무시되지만 예외가 발생하면 예외 객체를 생성하고, 예외 처리 구문을 실행하는데 성능에 영향을 줄 수 있습니다. 
    예외를 던지는 데는 비용이 크므로 예외가 자주 발생할 경우 성능이 떨어질 수 있습니다.


6. 에러 추적

- if문: if문은 오류를 검사하고 처리하는 방식이므로, 예외를 던지지 않으므로 오류가 발생한 위치나 원인을 추적하기 어렵습니다. 
    주로 오류를 return 값으로 처리하게 됩니다.

- try-catch: 예외를 던지면 오류 발생 지점과 예외 메시지를 추적할 수 있습니다. 
    예외 객체를 통해 오류의 원인을 구체적으로 알 수 있기 때문에 디버깅에 유리합니다.


