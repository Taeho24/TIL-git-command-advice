# 시그널 (Signal)

- 소프트웨어 인터럽트로 프로세스에 뭔가 발생했음을 알리는 간단한 메시지를 비동기적으로 보내는 것

- 0으로 나누기처럼 프로그램에 예외적인 상황이 일어나는 경우나 프로세스가 함수를 사용해 다른 프로세스에 시그널을 보내는 경우에 발생
- 보통 시그널로 전달되는 메시지는 무엇이 발생했는지를 표시하는 미리 정의된 상수를 사용
- 시그널을 받은 프로세스는 시그널에 따른 (1)기본 동작을 수행하거나, (2)시그널을 무시하거나, 시그널 처리를 위해 특별히 (3)지정된 함수를 수행


- 시그널 핸들러(Signal Handler)
    - 프로세스를 종료하기 전에 처리할 작업이 남아 있는 경우, 특정 시그널은 종료하고 않고자 하는 경우 시그널을 처리하는 함수를 지정하는 것

- 시그널 집합
    - POSIX에서 복수의 시그널을 처리하기 위해 도입한 개념
    - 시그널 집합을 사용하면 여러 시그널을 지정해 처리할 수 있음

- 시그널 제어 함수
    - sigaction() 함수는 시그널을 받아 이를 처리할 시그널 핸들러를 지정할 뿐만 아니라 플래그를 설정해 시그널 처리 과정을 제어할 수도 있음

- 알람 시그널
    - 일정 시간이 지난 후에 자동으로 시그널이 발생하도록 함
    - 일정 시간 후에 한 번 발생시킬 수도 있고, 일정한 시간 간격을 두고 주기적으로 알람 시그널을 발생시킬 수도 있음

--- 

## 시그널이란?
- 시그널은 소프트웨어 인터럽트
- 시그널은 비동기적(CPU의 clock에 영향X)으로 발생하며, 리눅스 운영체제가 프로세스에 전달
- 시그널은 다음과 같은 세 가지 경우에 발생
    1. 0으로 나누기처럼 프로그램에서 예외적인 상황이 일어나는 경우
    2. 프로세스가 `kill()` 함수와 같이 시그널을 보낼 수 있는 함수를 사용해 다른 프로세스에 시그널을 보내는 경우
    3. 사용자가 `Ctrl + C` 같은 인터럽트 키를 입력한 경우

- 기본 동작 수행
    - 대부분 시그널의 기본 동작은 프로세스를 종료하는 것
    - 이 외에 시그널을 무시하거나 프로세스 수행 일시 중지/재시작 등을 기본 동작으로 수행

- 시그널 무시
    - 프로세스가 시그널을 무시하기로 지정하면 시스템은 프로세스에 시그널을 전달하지 않음

- 지정된 함수 호출
    - 프로세스는 시그널의 처리를 위해 미리 함수를 지정해놓고 시그널을 받으면 해당 함수를 호출해 처리
    - 시그널 핸들러(Signal Handler): 시그널 처리를 위해 지정하는 함수
    - 시그널을 받으면 기존 처리 작업을 중지한 후 시그널 핸들러를 호출
    - 시그널 핸들러의 동작이 완료되면 기존 처리 작업을 계속 수행

- 시그널의 종류
    - 리눅스에서 사용되는 시그널의 개수는 시스템과 아키텍처에 따라 약간씩 다름
    - 일반적인 리눅스 시스템
        - `~$ kill -l`로 확인 가능
        - <signal.h> 파일에 정의
        - 1~31번까지의 표준 시그널(Standard Signals)
        - 32번 이상 확장 시그널(Real-time Signals)

## 주요 시그널 목록

| 시그널     | 번호 | 기본 처리   | 발생 요건                                                |
|------------|------|--------------|-------------------------------------------------------|
| SIGINT     | 2    | 종료         | 사용자가 `Ctrl+C`를 입력하면 발생                       |
| SIGQUIT    | 3    | 코어 덤프    | 사용자가 `Ctrl+\`를 입력하면 발생                       |
| SIGABRT    | 6    | 코어 덤프    | `abort()` 함수 호출 시 발생                             |
| SIGKILL    | 9    | 종료         | 강제 종료, 무시하거나 핸들링할 수 없음                   |
| SIGUSR1    | 10   | 종료         | 사용자 정의 시그널 1, 프로세스 간 사용자 정의 통신에 사용 |
| SIGUSR2    | 12   | 종료         | 사용자 정의 시그널 2                                    |
| SIGALRM    | 14   | 종료         | `alarm()` 함수 호출 후 시간 경과 시 발생                |
| SIGCHLD    | 17   | 무시         | 자식 프로세스의 상태가 바뀌었을때 발생                   |
| SIGCONT    | 18   | 무시         | 중지된 프로세스를 재시작 할때 발생                       |
| SIGSTOP    | 19   | 중지         | 중지(STOP)시그널, SIGCONT 시그널은 받을때까지 프로세스 수행 중단 (핸들링 불가) |
| SIGTSTP    | 20   | 중지         | 사용자가 `Ctrl+Z`를 입력 시 발생                        |


## 시그널 종류

### 표준 시그널 (Standard Signals)

| 항목       | 내용                                                     |
|------------|---------------------------------------------------------|
| 번호 범위  | 1 ~ 31                                                   |
| 예시       | `SIGINT`, `SIGTERM`, `SIGKILL`, `SIGSEGV`, `SIGCHLD` 등  |
| 큐잉 지원  | 같은 시그널 여러 번 보내도 1회로 처리됨                    |
| 우선순위   | 없음                                                     |
| 처리 순서  | 도착 시 즉시 처리 (시그널 핸들러 등록 시)                  |
| 용도       | 전통적 시스템 이벤트 처리 (중단, 종료, 예외 등)            |

### 실시간 시그널 (Real-time Signals)

| 항목       | 내용                                                     |
|------------|---------------------------------------------------------|
| 번호 범위  | 보통 32 ~ 64 (glibc 기준 `SIGRTMIN` ~ `SIGRTMAX`)        |
| 예시       | `SIGRTMIN + n` (사용자 정의 목적)                        |
| 큐잉 지원  | 여러 개의 시그널이 순서대로 큐에 저장됨                    |
| 우선순위   | 낮은 번호 우선 처리                                       |
| 처리 순서  | 도착 순서대로 정확히 처리 가능                            |
| 용도       | 고정밀 IPC, 커널-유저 공간 통신 등                        |


--- 

## 시그널 보내기: kill(2)
```
#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid, int sig);
```
pid_t pid : 시그널을 받을 프로세스의 PID 
int sig : pid로 지정한 프로세스에 보내는 시그널

- pid에 대응하는 프로세스에 sig로 지정한 시그널을 전송
- pid는 특정 프로세스 또는 프로세스 그룹을 의미
- sig에 0(널 시그널)을 지정하면 실제로 시그널을 보내지 않고 오류를 확인, 예를 들면, pid가 정상인지 검사

- pid에 지정한 값에 따라 시그널을 어떻게 보낼 것인지를 결정
- pid가 0보다 큰 수 : pid로 지정한 프로세스에 시그널을 전송
- pid가 -1이 아닌 음수 : 프로세스 그룹 ID가 pid의 절댓값인 프로세스 그룹에 속하고 시그널을 보낼 권한이 있는 모든 프로세스에 시그널을 전송
- pid가 0 : 특별한 프로세스(스케줄러 등)를 제외하고 프로세스 그룹 ID가 시그널을 보내는 프로세스의 프로세스 그룹 ID와 같은 모든 프로세스에 시그널을 전송
- pid가 -1 : 시그널을 보내는 프로세스의 유효 사용자 ID가 root(수퍼 유저)가 아니면, 특별한 프로세스를 제외하고 프로세스의 실제 사용자 ID가 시그널을 보내는 프로세스의 유효 사용자 ID와 같은 모든 프로세스에게 시그널을 전송
    - 즉, 접근 가능한 모든 프로세스에 시그널을 보냄


--- 

## 코어 덤프 파일이란?

- 코어 덤프(Core Dump)는 프로세스가 **비정상적으로 종료**될 때, 그 당시의 **메모리 상태를 저장한 파일**입니다.  
- **디버깅 목적**으로 사용되며, 프로그램이 **왜, 어디서, 어떻게** 죽었는지를 분석하는 데 중요한 단서를 제공합니다.

| 항목         | 설명                                                            |
|--------------|-----------------------------------------------------------------|
| 정의         | 프로세스가 크래시(예: segmentation fault) 되었을 때, 그 시점의 메모리 상태, 레지스터, 스택, 힙 정보 등을 담은 스냅샷 |
| 목적         | 프로그램의 버그, 메모리 오류, 예외 발생 원인을 디버깅하기 위해 사용 |
| 형식         | 이진 파일 (gdb 등 디버깅 도구로 해석 가능)                        |
| 생성 시점    | 보통 `SIGSEGV`, `SIGABRT`, `SIGFPE` 같은 치명적 시그널 수신 시    |
| 주요 사용 도구 | `gdb`, `coredumpctl`, `lldb` 등                                |

--- 

## 시그널 보내기 : raise(3)
```
#include <signal.h>         [함수 원형]
int raise(int sig);
```
int sig : 보내려는 시그널 번호

- raise() 함수는 호출한 프로세스에 인자로 지정한 시그널을 전송
- 만약 시그널 핸들러가 호출되면 시그널 핸들러의 수행이 끝날 때까지 raise() 함수는 리턴하지 않음
- 함수는 수행에 성공하면 0을, 실패하면 –1을 리턴

---

## 시그널 보내기 : abort(3)
```
#include <stdlib.h> [함수 원형]
void abort(void);
```

- 호출한 프로세스에 SIGABRT 시그널을 전송
- SIGABRT 시그널: 프로세스를 비정상적으로 종료시키고 코어 덤프 파일을 생성, 최소한 해당 프로세스가 연 파일은 모두 닫음
- SIGABRT 시그널은 abort() 함수는 raise(SIGABRT)와 같은 동작을 수행하 지만 프로세스를 종료시키므로 리턴하지 않음

--- 

## 시그널 핸들러 지정 : signal(3)
```
#include <signal.h>                         [함수 원형]
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
```
signum : 시그널 핸들러로 처리하려는 시그널
handler : 시그널 핸들러의 함수명

리턴값: 
    - 성공: **기존 핸들러 함수 포인터 반환**
    - 실패: SIG_ERR 반환
- 시그널을 처리하는 가장 단순한 함수로, 시그널을 받을 때 해당 시그널을 처리할 함수나 상수를 지정할 수 있음
- 첫 번째 인자인 signum에는 **SIGKILL(9)과 SIGSTOP(19) 시그널을 제외한 모든 시그널을 지정할 수 있음**
- 두 번째 인자인 handler에는 signum으로 지 정한 시그널을 받았을 때 처리할 방법을 지정

handler 설정
    - 시그널 핸들러 주소
    - SIG_IGN : 시그널을 무시하도록 지정
    - SIG_DFL : 시그널의 기본 처리 방법을 수행하도록 지정

- 버전 별 signal() 함수의 동작
- 시스템 V : 시그널을 처리한 후 시그널 처리 방법을 기본 처리 방법(SIG_DFL)으로 재설정,
    따라서 시그널 처리를 계속하려면 signal() 함수를 호출해 **시그널을 처리한 후 다시 signal() 함수를 설정해야 함**
- BSD : 시그널을 처리한 후 시그널 처리 방법을 기본 처리 방법(SIG_DFL)으로 재설정하지 않음,
    따라서 시그널 핸들러가 계속 동작
- 리눅스 : 커널의 signal(2) 시스템 콜은 시스템 V와 같은 방식으로 동작, 
    그러나 gcc의 glibc 2부터 signal(3) 함수는 호출하지 않고 sigaction(2)를 호출해 BSD 형식으로 동작

```signal()함수 예제
01 #include <unistd.h>
02 #include <signal.h>
03 #include <stdlib.h>
04 #include <stdio.h>
05
06 void sig_handler(int signo) {
07  printf("Signal Handler signum: %d\n", signo);
08  psignal(signo, "Received Signal");
09 }
---
> diff (솔라리스)
06 void sig_handler(int signo) {
07  void (*hand)(int);
08
09  hand = signal(SIGINT, sig_handler);
10  if (hand == SIG_ERR) {
11      perror("signal");
12      exit(1);
13  }
14  printf("Signal Handler Signal Number : %d\n", signo);
15  psignal(signo, "Received Signal");
16 }

---
10
11 int main() {
12  void (*hand)(int);
13
14  hand = signal(SIGINT, sig_handler);
15  if (hand == SIG_ERR) {
16      perror("signal");
17      exit(1);
18  }
19
20  printf("Wait 1st Ctrl+C... : SIGINT\n");
21  pause();
22  printf("After 1st Signal Handler\n");
23  printf("Wait 2nd Ctrl+C... : SIGINT\n");
24  pause();
25  printf("After 2nd Signal Handler\n");
26 }
```

--- 

## 시그널 핸들러 지정 : sigset()  ,외부적으론 signal()과 같음
```
#include <signal.h> [함수 원형]
sighandler_t sigset(int sig, sighandler_t disp);
```
sig : 시그널 핸들러로 처리하려는 시그널
disp : 시그널 핸들러의 함수명

- sigset() 함수의 인자 구조는 signal() 함수와 동일
- sigset() 함수도 첫 번째 인자인 sig 에 SIGKILL과 SIGSTOP 시그널을 제외한 어떤 시그널이든 지정할 수 있음
- 두 번째 인자인 disp에도 signal() 함수처럼 시그널 핸들러 함수의 주소나 SIG_IGN, SIG_DFL 중 하나를 지정해야 함

- 리턴값은 시그널 핸들러 함수의 주소
- sigset() 함수가 실패하면 SIG_ERR을 리턴

- 리눅스에서는 sigset() 함수를 제공하지만 사용을 권하지는 않음


---

## `signal()`과 `sigset()`의 공통점 및 차이점

### 공통점

| 항목         | 설명                                                                 |
|--------------|----------------------------------------------------------------------|
| 목적         | 특정 시그널 발생 시 실행할 시그널 핸들러를 등록                     |
| 인자         | 시그널 번호와 핸들러 함수 포인터를 전달                             |
| 반환값       | 이전에 등록된 핸들러의 함수 포인터 (또는 오류 시 `SIG_ERR`)         |
| 사용 환경    | UNIX, Linux 계열 시스템에서 모두 사용 가능                          |
| 사용 예      | `SIGINT`, `SIGTERM`, `SIGUSR1` 등의 사용자 정의 핸들링               |

### 차이점

| 항목              | `signal()`                                | `sigset()` (System V)                    |
|-------------------|--------------------------------------------|------------------------------------------|
| 표준 여부         | POSIX 표준 함수                           | System V 확장 함수 (비표준)              |
| 재설정 여부       | 일부 시스템에서는 시그널 처리 후 핸들러가 기본값으로 재설정됨 | 핸들러가 자동으로 유지됨 (재설정되지 않음) |
| 시그널 블록 여부  | 핸들러 실행 중 해당 시그널이 자동 블록되지 않음(일부 구현에서는 예외 존재) | 핸들러 실행 중 시그널이 자동으로 블록됨 |
| 대체 함수         | `sigaction()` 으로 대체 사용 권장          | `sigaction()` 사용 권장                  |
> ✅ **권장 사항**: 두 함수 모두 **현대 시스템에서는 `sigaction()`으로 대체**하여 사용하는 것이 더 안전하고 유연합니다.

--- 

# 시그널 집합

- 시그널을 비트 마스크로 표현한 것으로, 시그널 하나가 비트 하나를 가 킴
- 각 비트가 특정 시그널과 1:1로 연결되어 있음
- 비트값이 1이면 해당 시그널이 설정 된 것이고 0이면 시그널이 설정되지 않은 것
- 시스템에서는 시그널 집합의 처리를 위해 sigset_t라는 구조체를 제공

```Linux
typedef struct {
    unsigned long __val[_NSIG_WORDS];
} sigset_t;
```

```솔라리스
typedef struct {
    unsigned int __sigbits[4];
} sigset_t
```

--- 




