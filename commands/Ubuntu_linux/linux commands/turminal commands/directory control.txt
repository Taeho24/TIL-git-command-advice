# 리눅스의 파일 확장자 유형

- 파일의 유형이나 용도를 판단하기 위해 확장자를 사용하지 않아도 된다.
- 리눅스에서는 파일의 유형을 확인할 때 파일 이름(또는 확장자)이 아니라 파일의 메타데이터와 내용을 기준으로 판단한다.

- 확장자가 없을 경우의 장점
    - 유연성과 자유 : 파일 이름에 강제적인 규칙이 없어 사용자나 시스템 설계자가 자유롭게 파일 이름을 설정할 수 있다.
    - 보안 : 파일의 실제 유형을 숨길 수 있어 악성 파일이나 스크립트가 쉽게 노출되지 않는다.
    - OS 설계 철학과 일관성 : 리눅스의 설계 철학에 부합한다. 이름보다 내용에 의존한다.

- 확장자가 없을 경우의 단점
    - 가시성 부족 : 확장자가 없으면 사용자가 파일의 내용을 확인하기 전에는 파일 유형을 알 수 없다.
    - 다른 OS와의 호환성 : 윈도우는 파일 확장자를 기준으로 파일 유형을 판단하기 때문에 확장자가 없는 파일을 처리하는데 문제가 된다.


# directory 생성
~$ mkdir <절대/상대경로> <디렉토리 이름>

# 목록 확인
~$ ls // option: (-a)/(-l) // ex. ~$ ls -l run

~$ ls *.txt // ~$ ls | grep txt

~$ ls *zzz > zzz_file > error.msg // ~$ ls // zzz_file error.msg


# 화면 크기 단위로 파일 내용 출력
~$ more [파일이름]
~$ ls | more [파일이름]

# 파일 위치 찾기 find

~$ find ./ -name '*.txt' // (현재 디렉토리~하위 디렉토리)확장자 .txt인 파일들 목록

~$ find ./ -type d -name '*test*' // (현재 디렉토리~하위 디렉토리)이름에 test가 들어간 디렉토리 목록

# 목록 이동
~$ cd // 내장명령어 // $whereis cd // cd: // 안나옴

# 파일 내용 확인
~$ cat [파일이름]

# 새로만들기||덮어씌우기
~$ vi [파일이름]

~$ cat > [파일이름]
Ctrl+d // 쓰기 종료

~$ echo "(내용)" > [파일이름]

# 내용 추가하여 이어쓰기
~$ cat >> [파일이름]

~$ echo "(내용)" >> [파일이름]

# RAM 정보 확인
~$ cat /proc/meminfo

# RAM 사용량 확인
~$ free (또는, free -h)

# HDD 사용량 확인
~$ df -h

# GPU 확인
~$ nvidia-sml

# 네트워크 상태 확인
~$ netstat -tnlp

# URL로 파일 다운로드
~$ wget https://~


# 파일복사
~$ cp <from경로> <to경로>               // 파일복사
~$ cp -r <디렉토리 이름> <디렉토리 이름>    // 디렉토리 복사
~$ cat [파일이름] > [파일이름]

~$ cat [file1] [file2] > [file3] // file1과 file2의 내용을 합쳐 file3 만들기

# 파일 삭제
~$ rm [파일이름] [파일이름]

~$ rmdir <디렉토리 이름> // 비어있는 디렉토리 삭제
~$ rmdir <디렉토리 이름> // 하위 디렉토리까지 모두 삭제

~$ rm .[파일이름].sw* // 임시파일 삭제


# 파일 이동
~$ mv <./[파일이름](form)> <./경로(to)> // 이름변경에도 사용됨


# 파일 소유, 권한 변경
~$ chown 사용자명:그룹명 ./[파일이름] // 소유 변경

~$ chmod 권한(8진수) ./[파일이름] // 소유자, 그룹, 제3자 순서

# 프로세스 명령어
## 현재 실행 중인 프로세스의 정보 출력
~$ ps // ~$ ps -elf

## 프로세스 강제 종료 시스널 -9:강제종료
~$ kill 5001 // ~$ kill -9 5001


# 파일 위치 검색
~$ whereis (ls)


# 리눅스 시스템 접속  해제
~$ exit


# echo $
~$ echo $? // "마지막으로 종료된 명령어의 종료 상태" 출력
~$ echo $! // "마지막으로 백그라운드에서 실행된 명령어 PID값" 출력
~$ echo $$ // "현재 쉘의 PID값"출력

