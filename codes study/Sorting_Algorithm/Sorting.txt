# Ssorting_Algorithm

| 알고리즘       | 최악의 경우         | 평균적인 경우        |
|----------------|--------------------|----------------------|
| 선택 정렬      | O(n²)               | O(n²)               |
| 버블 정렬      | O(n²)               | O(n²)               |
| 삽입 정렬      | O(n²)               | O(n²)               |
| 병합 정렬      | O(n log n)          | O(n log n)          |
| **퀵 정렬**    | O(n²)               | O(n log n)          |
| 힙 정렬        | O(n log n)          | O(n log n)          |
| 계수 정렬      | O(n + k) == O(n)    | O(n + k) == O(n)    |
| 버킷 정렬      | O(n²) (최악의 경우), O(n log n) (균등 분포일 경우) | O(n) (균등 분포일 경우) |
| 기수 정렬      | O(nk)  == O(n)      | O(nk) == O(n)       |

## 설명:
- 선택 정렬(Selection Sort): 매번 남은 원소들 중에서 최솟값을 찾아서 자리를 바꾸므로, 최악의 경우와 평균적인 경우 모두 O(n²)입니다.
- 버블 정렬(Bubble Sort): 매번 인접한 원소들을 비교하며 정렬하므로, 최악의 경우와 평균적인 경우 모두 O(n²)입니다.
- 삽입 정렬(Insertion Sort): 각 원소를 삽입할 때 이전의 원소들과 비교해 정렬하므로 최악과 평균 모두 O(n²)입니다.
                            O(n²) 에 속하는 알고리즘이지만, 거의 **정렬된 상태**면 O(n) 에 근접한 복잡도
- 병합 정렬(Merge Sort): 배열을 재귀적으로 분할하고 병합할 때 O(n log n)의 시간이 걸리므로 최악과 평균 모두 O(n log n)입니다.
- **퀵 정렬(Quick Sort)**: 최악의 경우에는 피벗 선택이 불리하면 O(n²)까지 시간이 걸리지만, 평균적으로는 좋은 피벗 선택을 하면 O(n log n)입니다.
- 힙 정렬(Heap Sort): 힙을 구성하고 힙에서 원소를 추출하는 데 O(n log n)의 시간이 걸리므로 최악과 평균 모두 O(n log n)입니다.
- 계수 정렬(Counting Sort): 입력의 범위가 k일 때, O(n + k)의 시간이 걸리며, n은 입력의 크기이고 k는 값의 범위입니다. 범위가 크지 않다면 효율적으로 사용할 수 있습니다.
- 버킷 정렬(Bucket Sort): 최악의 경우, 모든 값이 하나의 버킷에 몰리면 O(n²)이 됩니다. 그러나 값들이 균등 분포되어 있으면 평균적으로 O(n) 또는 O(n log n)으로 정렬할 수 있습니다.
- 기수 정렬(Radix Sort): 정렬할 데이터의 자릿수(k)에 따라 O(nk) 시간이 걸립니다. 자릿수가 적으면 매우 빠르게 정렬할 수 있습니다.
