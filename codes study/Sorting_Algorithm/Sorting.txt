# Sorting_Algorithm

| 정렬 알고리즘 | 최악 시간 복잡도                   | 평균 시간 복잡도  | 비고                    |
| ----------- | ----------------------------------- | --------------- | ----------------------- |
| 선택 정렬   | O(n²)                               | O(n²)            | 비교 기반, 구현 쉬움     |
| 버블 정렬   | O(n²)                               | O(n²)            | 거의 정렬된 경우 O(n)    |
| 삽입 정렬   | O(n²)                               | O(n²)            | 거의 정렬된 경우 O(n)    |
| 병합 정렬   | O(n log n)                          | O(n log n)       | 안정 정렬, 추가 메모리 O(n) 필요 |
| **퀵 정렬** | **O(n²)**                           | **O(n log n)**   | 평균적으로 가장 빠름, 제자리 정렬(보통) |
| 힙 정렬     | O(n log n)                          | O(n log n)       | 추가 메모리 거의 필요 없음       |
| 계수 정렬   | O(n + k) == O(n)                    | O(n + k) == O(n) | k는 값의 범위, 정수 기반만 가능  |
| 버킷 정렬   | O(n²) (최악), O(n log n) (균등 분포) | O(n) (균등 분포) | 값이 균등 분포일 때 효과적       |
| 기수 정렬   | O(nk) == O(n)                       | O(nk) == O(n)    | k는 자릿수, 정수 또는 문자열에 사용 |

## 설명:
- 선택 정렬(Selection Sort): 매번 남은 원소들 중에서 최솟값을 찾아서 자리를 바꾸므로, 최악의 경우와 평균적인 경우 모두 O(n²)입니다.
- 버블 정렬(Bubble Sort): 매번 인접한 원소들을 비교하며 정렬하므로, 최악의 경우와 평균적인 경우 모두 O(n²)입니다.
- 삽입 정렬(Insertion Sort): 각 원소를 삽입할 때 이전의 원소들과 비교해 정렬하므로 최악과 평균 모두 O(n²)입니다.
                            O(n²) 에 속하는 알고리즘이지만, 거의 **정렬된 상태**면 O(n) 에 근접한 복잡도
- 병합 정렬(Merge Sort): 배열을 재귀적으로 분할하고 병합할 때 O(n log n)의 시간이 걸리므로 최악과 평균 모두 O(n log n)입니다.
- **퀵 정렬(Quick Sort)**: 최악의 경우에는 피벗 선택이 불리하면 O(n²)까지 시간이 걸리지만, 평균적으로는 좋은 피벗 선택을 하면 O(n log n)입니다.
- 힙 정렬(Heap Sort): 힙을 구성하고 힙에서 원소를 추출하는 데 O(n log n)의 시간이 걸리므로 최악과 평균 모두 O(n log n)입니다.
- 계수 정렬(Counting Sort): 입력의 범위가 k일 때, O(n + k)의 시간이 걸리며, n은 입력의 크기이고 k는 값의 범위입니다. 범위가 크지 않다면 효율적으로 사용할 수 있습니다.
- 버킷 정렬(Bucket Sort): 최악의 경우, 모든 값이 하나의 버킷에 몰리면 O(n²)이 됩니다. 그러나 값들이 균등 분포되어 있으면 평균적으로 O(n) 또는 O(n log n)으로 정렬할 수 있습니다.
- 기수 정렬(Radix Sort): 정렬할 데이터의 자릿수(k)에 따라 O(nk) 시간이 걸립니다. 자릿수가 적으면 매우 빠르게 정렬할 수 있습니다.

| 질문                            | 답                |
| ------------------------------- | ---------------- |
| 평균적으로 더 빠른 것은?         | 퀵정렬            |
| 최악에도 성능이 안정적인가?       | 힙정렬           |
| 메모리 적게 쓰는가?              | 힙정렬            |
| 실제 프로그래밍에서 더 많이 쓰나? | 퀵정렬(변형 포함) |

## 퀵정렬의 변형 알고리즘
| 변형 종류                                    | 핵심 아이디어                                   | 장점                             | 단점                        | 시간 복잡도                 | 실제 사용                                 |
| ------------------------------------------- | ----------------------------------------------- | ------------------------------- | --------------------------- | -------------------------- | ----------------------------------------- |
| **기본 퀵정렬 (Naive Quick Sort)**           | 첫 요소/마지막 요소를 피벗으로 선택               | 구현 간단, 평균적으로 빠름       | 최악 O(n²), 특정 입력에 취약 | 평균 O(n log n), 최악 O(n²) | 학습용                                    |
| **랜덤 퀵정렬 (Randomized Quick Sort)**      | 피벗을 무작위 선택                               | 최악 상황 방지, 보안 위험 감소   | 난수 생성 비용               | 평균 O(n log n), 최악 희박  | 알고리즘 문제, 안전한 기본 구현            |
| **Median-of-Three Quick Sort**              | (앞/중간/뒤) 3개 값의 중간값을 피벗으로 사용      | 균형 잡힌 분할 → 성능 우수       | 코드 복잡 증가               | 평균 O(n log n), 최악 O(n²) | 실무 구현, 일부 라이브러리                 |
| **Median-of-Five, 샘플링 기반 Quick Sort**   | 여러 값 샘플링하여 더 정확한 중간값 사용          | 더 균형 잡힌 분할 → 성능 안정    | 샘플링 비용 증가             | 평균 O(n log n)             | 성능 민감 코드                            |
| **Lomuto Partition Quick Sort**             | 단순한 파티션 방식                               | 코드 간결                       | 성능 및 스왑 많음            | 평균 O(n log n)             | 교육용(기본 코드)                         |
| **Hoare Partition Quick Sort**              | 피벗 기준 양쪽에서 좁혀가는 방식                  | 스왑 적고 성능 좋음             | 구현이 약간 복잡              | 평균 O(n log n)             | 실제 구현에서 선호                       |
| **Dual-Pivot Quick Sort**                   | 피벗을 2개 사용하여 3개 구간으로 분할             | 분할 효율 ↑ → 실제 속도 증가     | 파티션 논리 복잡             | 평균 O(n log n)             | ⭐ Java Arrays.sort(int[]) 기본 알고리즘 |
| **Quick + Insertion Sort Hybrid**           | 작은 배열 구간에서는 삽입 정렬로 전환             | 실제 속도 크게 향상              | 두 알고리즘 결합 필요        | 평균 O(n log n)             | 대부분의 고성능 구현                      |
| **Introsort (Introspective Sort)**          | 재귀 깊이가 일정 threshold 이상이면 힙정렬로 전환 | 최악 시간 복잡도 O(n log n) 보장 | 구현 복잡                    | 평균 & 최악 모두 O(n log n) | ⭐ C++ STL sort() 표준 알고리즘          |
| **비재귀 Quick Sort (Non-recursive)**       | 스택을 직접 관리                                 | 스택 오버플로우 방지             | 코드 복잡                    | 평균 O(n log n)             | 임베디드/스택 제한 환경                   |
| **3-way Partition Quick Sort (Dutch Flag)** | 동일값 모음 구간 포함하여 3구간 분할             | 중복 값 많을 때 매우 빠름         | 구현 난도 증가               | 평균 O(n) (중복 많을 때)     | 문자열 정렬, 데이터 중복 많을 때          |
