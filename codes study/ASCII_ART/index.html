<!-- 출처: https://www.youtube.com/watch?v=8tGIj076_8Q -->
<!-- 참고: https://en.wikipedia.org/wiki/Whitespace_character -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII Art Generator</title>

    <style>
    body {
      margin: 0;
      font-family: 'Consolas', monospace;
      line-height: 85%;
      letter-spacing: 2px;
      font-size: 10px;
    }
    #canvas, #ascii-canvas {
      display: block;
      margin-bottom: 10px;
      border: 1px solid gray;
    }
    #ascii-output {
      white-space: pre;
      font-size: 10px;
      line-height: 1;
      margin-top: 10px;
    }
    #drop-area {
      border: 2px dashed #ccc;
      padding: 20px;
      margin: 15px 0;
      min-height: 200px;
      background-color: #f9f9f9;
      display: flex;
      justify-content: center; /* 가로 중앙 */
      align-items: center;     /* 세로 중앙 */
      text-align: center;      /* 텍스트가 여러 줄일 때 가운데 정렬 */
    }
    </style>

</head>
<body>
    <h2>🎨 ASCII Art Generator</h2>

    <div style="margin:10px;">
        <label>이미지 크기 비율: <input id="scaleInput" type="number" min="0.1" max="1" step="0.1" value="1" style="width:50px;"> (0.1~1)</label>
        <label title="픽셀 간격이 너무 작으면 이미지가 너무 길어짐. 적당히 조절하세요."style="margin-left:15px;">변환 픽셀 간격(px): <input id="gapInput" type="number" min="1" max="20" step="1" value="5" style="width:50px;"></label>
        <label style="margin-left:15px;">폰트 크기(px): <input id="fontSizeInput" type="number" min="2" max="20" step="1" value="6" style="width:50px;"></label>
        <br><br>
        <label>ASCII 문자셋: <input id="asciiInput" type="text" value="@$#Y!=+~- " style="width:200px;"></label>
        <button id="generateBtn" style="margin-left:15px;">다시 생성</button>
    </div>

    <input type="file" id="fileInput" accept="image/*">
    <pre id="drop-area">
        이미지를 드래그하여 여기에 놓거나, 아래 버튼으로 업로드하세요.
    </pre>
    <canvas id="canvas"></canvas>
    <canvas id="ascii-canvas" style="display:none;"></canvas>
    <h4 id="ascii-output"> </h4>
    <div style="margin:10px 0;">
        <button id="downloadTxtBtn">TXT 텍스트 저장</button>
        <button id="downloadPngBtn">PNG 이미지 저장</button>
        <label>
            <input type="checkbox" id="transparentBgCheckbox" title="체크 해제 시 배경이 흰색으로 채워짐" checked>
                배경 투명
        </label>
    </div>

    <!-- gifuct-js 라이브러리 로드 -->
    <script type="module">
        // gifuct 객체에서 함수 꺼내기
        import { parseGIF, decompressFrames } from 'https://cdn.jsdelivr.net/npm/gifuct-js/+esm';

        const canvas = document.querySelector('canvas')
        const ctx = canvas.getContext('2d')
        const asciiCanvas = document.getElementById('ascii-canvas');
        const asciiCtx = asciiCanvas.getContext('2d');

        const output = document.getElementById('ascii-output');
        
        const dropArea = document.getElementById('drop-area');
        const fileInput = document.getElementById('fileInput');
        
        const scaleInput = document.getElementById('scaleInput');
        const gapInput = document.getElementById('gapInput');
        const fontSizeInput = document.getElementById('fontSizeInput');
        const asciiInput = document.getElementById('asciiInput');
        const generateBtn = document.getElementById('generateBtn');

        const transparentBgCheckbox = document.getElementById('transparentBgCheckbox');
        const downloadTxtBtn = document.getElementById('downloadTxtBtn');
        const downloadPngBtn = document.getElementById('downloadPngBtn');

        let asciiImage = '';        
        let currentImg = new Image();
        currentImg.crossOrigin = "anonymous";  // 만약 CORS 문제 생길 시
        currentImg.src = 'src/img/free-icon-transform-text.png';

        let animationFrames = null;
        let animationIndex = 0;
        let animationTimer = null;

        function getCharSafe(chars, index, defaultChar = ' ') {
            return (index >= 0 && index < chars.length) ? chars[index] : defaultChar;
        }

        function generateASCIIFromImage(sourceImage) {
            const scale = parseFloat(scaleInput.value);
            const gap = parseInt(gapInput.value);
            const fontSize = parseInt(fontSizeInput.value);
            const asciiChars = asciiInput.value;

            if (isNaN(scale) || scale <= 0 || scale > 1) {
                alert('이미지 크기 비율은 0.1 ~ 1 사이의 숫자여야 합니다.');
                return;
            }
            if (isNaN(gap) || gap < 1 || gap > 20) {
                alert('픽셀 간격은 1 ~ 20 사이의 정수여야 합니다.');
                return;
            }
            if (isNaN(fontSize) || fontSize < 2 || fontSize > 20) {
                alert('폰트 크기는 2 ~ 20 사이의 정수여야 합니다.');
                return;
            }
            if (!asciiChars || asciiChars.length < 2) {
                alert('ASCII 문자셋은 최소 2개 이상 입력하세요.');
                return;
            }

            const width = Math.max(1, Math.floor(sourceImage.width * scale));
            const height = Math.max(1, Math.floor(sourceImage.height * scale));

            // 크기에 맞춰 캔버스 크기 조정
            canvas.width = asciiCanvas.width = width;
            canvas.height = asciiCanvas.height = height;

            // 원본 이미지 그리기
            ctx.clearRect(0, 0, width, height);
            ctx.drawImage(sourceImage, 0, 0, width, height);

            // ASCII 캔버스 초기화
            asciiCtx.clearRect(0, 0, width, height);
            asciiCtx.fillStyle = 'black';
            asciiCtx.font = `${fontSize}px Consolas, monospace`;
            asciiCtx.textBaseline = 'top';

            // 캔버스 크기에 맞는 픽셀 데이터 가져오기
            const imageData = ctx.getImageData(0, 0, width, height).data;
            
            // 초기화
            asciiImage = '';

            for (let y = 0; y < height; y += gap) {
            let line = '';
            for (let x = 0; x < width; x += gap) {
                const index = (y * width + x) * 4;
                const r = imageData[index];
                const g = imageData[index + 1];
                const b = imageData[index + 2];
                const gray = 0.299 * r + 0.587 * g + 0.114 * b;

                const charIndex = Math.min(asciiChars.length - 1, Math.floor(gray / (256 / asciiChars.length)));
                const char = getCharSafe(asciiChars, charIndex);
                line += char;

                asciiCtx.fillText(char, x, y);
            }
            asciiImage += line + '\n';
            }
            // 한 번에 DOM에 반영
            output.innerText = asciiImage;
        }

        // GIF 애니메이션 ASCII 변환 함수 (프레임 이미지 받아서 ASCII 변환)
        function drawFrameAndGenerateASCII(canvasFrame) {
            generateASCIIFromImage(canvasFrame);
        }

        function animateGIF(frames, width, height) {
            if (animationTimer) clearTimeout(animationTimer);

            const frame = frames[animationIndex];
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');

            // 프레임 이미지 데이터 생성
            const imageData = tempCtx.createImageData(frame.dims.width, frame.dims.height);
            imageData.data.set(frame.patch);
            tempCtx.putImageData(imageData, frame.dims.left, frame.dims.top);

            // 완성된 캔버스를 이용해 ASCII 변환
            drawFrameAndGenerateASCII(tempCanvas);

            animationIndex = (animationIndex + 1) % frames.length;

            // delay가 0이면 기본 100ms로 처리
            const delay = frame.delay > 0 ? frame.delay * 10 : 100;
            animationTimer = setTimeout(() => animateGIF(frames, width, height), delay);
        }

        // 이미지 로드 이벤트
        currentImg.onload = () => {
            generateASCIIFromImage(currentImg);
        };

        currentImg.onerror = () => {
            if (!currentImg.src) {
                    alert('이미지 로드에 실패했습니다. 파일 경로나 네트워크 상태를 확인해주세요.');
            }
        };

        generateBtn.addEventListener('click', () => {
            if (animationFrames) {
                // GIF 애니메이션 중이면 재생 유지
                animateGIF(animationFrames, canvas.width, canvas.height);
            } else {
                generateASCIIFromImage(currentImg);
            }
        });
        // 원본 코드
        /*img.addEventListener('load', function(){
            ctx.drawImage(img, 0, 0)
            for (let j = 0; j < 300; j += 5){
                for (let i = 0; i < 300; i += 5){
                    let pixel = ctx.getImageData(i, j, 1, 1).data
                    let gray = 0.299*pixel[0] + 0.587*pixel[1] + 0.114*pixel[2]
                    let index = Math.floor(gray/25.6)
                    document.querySelector('h4').innerText += ascii[index]
                    if (i >= 295) {
                        document.querySelector('h4').innerHTML += '<br>'
                    }
                }
            }
        })*/

        function handleFile(file) {
            console.log("handleFile called, file:", file);
            if (!file || !file.type.startsWith('image/')) {
                alert('이미지 파일만 가능합니다.');
                return;
            }

            const reader = new FileReader();

            // GIF 처리
            if (file.type === 'image/gif') {
                reader.onload = e => {
                    const buffer = e.target.result;
                    const gif = parseGIF(buffer);
                    const frames = decompressFrames(gif, true);

                    // 전체 캔버스 크기 - GIF 전체 크기 기준
                    const gifWidth = gif.lsd.width;
                    const gifHeight = gif.lsd.height;

                    animationFrames = frames;
                    animationIndex = 0;

                    // 애니메이션 시작
                    animateGIF(animationFrames, gifWidth, gifHeight);
                };
                reader.readAsArrayBuffer(file);
            } else {
                // 일반 이미지
                reader.onload = e => {
                    if (animationTimer) clearTimeout(animationTimer);
                    animationFrames = null;
                    animationIndex = 0;

                    const newImg = new Image();
                    newImg.onload = () => {
                        currentImg = newImg;
                        generateASCIIFromImage(currentImg);
                    };
                    newImg.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        // 드래그 앤 드롭 기능 추가
        dropArea.addEventListener('dragover', e => {
            e.preventDefault();
            dropArea.style.background = '#f8f8f8';
        });

        dropArea.addEventListener('dragleave', () => {
            dropArea.style.background = '';
        });

        dropArea.addEventListener('drop', e => {
            e.preventDefault();
            dropArea.style.background = '';
            const file = e.dataTransfer.files[0];
            handleFile(file);
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            handleFile(file);
        });

        // dropArea 클릭 시 fileInput 클릭
        dropArea.addEventListener('click', () => {
            fileInput.click();
        });


        // 다운로드 버튼 클릭 시 파일 생성 및 다운로드
        // TXT 저장 버튼
        downloadTxtBtn.addEventListener('click', () => {
            let fileName = prompt("저장할 파일 이름을 입력하세요 (확장자 없이):", "ascii-art");
            if (!fileName) return;
            
            // 파일명에서 허용하지 않는 문자를 '_'로 변경
            fileName = fileName.replace(/[\\/:*?"<>|]/g, '_');

            if (!fileName.toLowerCase().endsWith('.txt')) fileName += '.txt';
            
            const blob = new Blob([asciiImage], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            URL.revokeObjectURL(url);
        });
        // PNG 저장 버튼
        downloadPngBtn.addEventListener('click', () => {
            let fileName = prompt("저장할 파일 이름을 입력하세요 (확장자 없이):", "ascii-art");
            if (!fileName) return;
            // 파일명 안전 처리
            fileName = fileName.replace(/[\\/:*?"<>|]/g, '_');

            if (!fileName.toLowerCase().endsWith('.png')) fileName += '.png';
            
            const isTransparent = transparentBgCheckbox.checked;

            // 임시 캔버스 생성
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = asciiCanvas.width;
            tempCanvas.height = asciiCanvas.height;

            if (!isTransparent) {
                // 배경 흰색 채우기
                tempCtx.fillStyle = 'white';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            } else {
                // 투명 배경 (기본 클리어)
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
            }

            // asciiCanvas 그림 복사
            tempCtx.drawImage(asciiCanvas, 0, 0);

            // Blob으로 변환 후 다운로드
            tempCanvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                // 결과물 새창열기
                window.open(url, '_blank');

                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                URL.revokeObjectURL(url);
            }, 'image/png');
        });
    </script>

</body>
</html>
