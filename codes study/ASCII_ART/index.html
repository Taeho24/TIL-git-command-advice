<!-- ì¶œì²˜: https://www.youtube.com/watch?v=8tGIj076_8Q -->
<!-- ì°¸ê³ : https://en.wikipedia.org/wiki/Whitespace_character -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII Art Generator</title>

    <style>
    body {
      margin: 0;
      font-family: 'Consolas', monospace;
      line-height: 85%;
      letter-spacing: 2px;
      font-size: 10px;
    }
    #canvas, #ascii-canvas {
      display: block;
      margin-bottom: 10px;
      border: none;
    }
    #ascii-output {
      white-space: pre;
      font-size: 10px;
      line-height: 1;
      margin-top: 10px;
    }
    #drop-area {
      border: 2px dashed #ccc;
      padding: 20px;
      margin: 15px 0;
      min-height: 200px;
      background-color: #f9f9f9;
      display: flex;
      justify-content: center; /* ê°€ë¡œ ì¤‘ì•™ */
      align-items: center;     /* ì„¸ë¡œ ì¤‘ì•™ */
      text-align: center;      /* í…ìŠ¤íŠ¸ê°€ ì—¬ëŸ¬ ì¤„ì¼ ë•Œ ê°€ìš´ë° ì •ë ¬ */
    }
    </style>

</head>
<body>
    <h2>ğŸ¨ ASCII Art Generator</h2>

    <div style="margin:10px;">
        <label>ì´ë¯¸ì§€ í¬ê¸° ë¹„ìœ¨: <input id="scaleInput" type="number" min="0.1" max="1" step="0.1" value="1" style="width:50px;"> (0.1~1)</label>
        <label title="í”½ì…€ ê°„ê²©ì´ ë„ˆë¬´ ì‘ìœ¼ë©´ ì´ë¯¸ì§€ê°€ ë„ˆë¬´ ê¸¸ì–´ì§. ì ë‹¹íˆ ì¡°ì ˆí•˜ì„¸ìš”."style="margin-left:15px;">ë³€í™˜ í”½ì…€ ê°„ê²©(px): <input id="gapInput" type="number" min="1" max="20" step="1" value="5" style="width:50px;"></label>
        <label style="margin-left:15px;">í°íŠ¸ í¬ê¸°(px): <input id="fontSizeInput" type="number" min="2" max="20" step="1" value="6" style="width:50px;"></label>
        <br><br>
        <label>ASCII ë¬¸ìì…‹: <input id="asciiInput" type="text" value="@$#Y!=+~-â€€" style="width:200px;"></label>
        <label style="margin-left:15px;">
            <input type="checkbox" id="aspectRatioCheckbox" title="ì²´í¬ ì‹œ ì™œê³¡ ê°€ëŠ¥ì„± ìˆìŒ" checked>
            ë¹„ìœ¨ ë³´ì • (ê°€ë¡œ ëŠ˜ë¦¬ê¸°)
        </label>

        <button id="generateBtn" style="margin-left:15px;">ë‹¤ì‹œ ìƒì„±</button>
    </div>

    <input type="file" id="fileInput" accept="image/*">
    <pre id="drop-area">
        ì´ë¯¸ì§€ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ì—¬ê¸°ì— ë†“ê±°ë‚˜, ì•„ë˜ ë²„íŠ¼ìœ¼ë¡œ ì—…ë¡œë“œí•˜ì„¸ìš”.
    </pre>
    <canvas id="canvas"></canvas>
    <canvas id="ascii-canvas" style="display:none;"></canvas>
    <h4 id="ascii-output"> </h4>
    <div style="margin:10px 0;">
        <button id="downloadTxtBtn">TXT í…ìŠ¤íŠ¸ ì €ì¥</button>
        <button id="downloadPngBtn">PNG ì´ë¯¸ì§€ ì €ì¥</button>
        <label>
            <input type="checkbox" id="transparentBgCheckbox" title="ì²´í¬ í•´ì œ ì‹œ ë°°ê²½ì´ í°ìƒ‰ìœ¼ë¡œ ì±„ì›Œì§" checked>
                ë°°ê²½ íˆ¬ëª…
        </label>
        <label style="margin-left:15px;">
            ì €ì¥ ì´ë¯¸ì§€(.png) ì„ ëª…ë„:
            <select id="resolutionSelect">
                <option value="1">1x</option>
                <option value="2" selected>2x</option>
                <option value="4">4x</option>
                <option value="8">8x</option>
            </select>
        </label>
    </div>

    <!-- gifuct-js ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ -->
    <script type="module">
        // gifuct ê°ì²´ì—ì„œ í•¨ìˆ˜ êº¼ë‚´ê¸°
        import { parseGIF, decompressFrames } from 'https://cdn.jsdelivr.net/npm/gifuct-js/+esm';

        const canvas = document.querySelector('canvas')
        const ctx = canvas.getContext('2d', { willReadFrequently: true })
        const asciiCanvas = document.getElementById('ascii-canvas');
        const asciiCtx = asciiCanvas.getContext('2d');

        const output = document.getElementById('ascii-output');
        
        const dropArea = document.getElementById('drop-area');
        const fileInput = document.getElementById('fileInput');
        
        const scaleInput = document.getElementById('scaleInput');
        const gapInput = document.getElementById('gapInput');
        const fontSizeInput = document.getElementById('fontSizeInput');
        const asciiInput = document.getElementById('asciiInput');
        const resolutionSelect = document.getElementById('resolutionSelect');
        const generateBtn = document.getElementById('generateBtn');
        const aspectFixCheckbox = document.getElementById('aspectRatioCheckbox');

        const transparentBgCheckbox = document.getElementById('transparentBgCheckbox');
        const downloadTxtBtn = document.getElementById('downloadTxtBtn');
        const downloadPngBtn = document.getElementById('downloadPngBtn');

        let asciiImage = '';        
        let currentImg = new Image();
        currentImg.crossOrigin = "anonymous";  // ë§Œì•½ CORS ë¬¸ì œ ìƒê¸¸ ì‹œ
        //currentImg.src = ''; // # (ì„ íƒì‚¬í•­)

        let animationFrames = null;
        let animationIndex = 0;
        let animationTimer = null;

        function getCharSafe(chars, index, defaultChar = 'â€€') {
            return (index >= 0 && index < chars.length) ? chars[index] : defaultChar;
        }

        function generateASCIIFromImage(sourceImage) {
            const scale = parseFloat(scaleInput.value);
            const gap = parseInt(gapInput.value);
            const fontSize = parseInt(fontSizeInput.value);
            const asciiChars = asciiInput.value;

            if (isNaN(scale) || scale <= 0 || scale > 1) {
                alert('ì´ë¯¸ì§€ í¬ê¸° ë¹„ìœ¨ì€ 0.1 ~ 1 ì‚¬ì´ì˜ ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤.');
                return;
            }
            if (isNaN(gap) || gap < 1 || gap > 20) {
                alert('í”½ì…€ ê°„ê²©ì€ 1 ~ 20 ì‚¬ì´ì˜ ì •ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.');
                return;
            }
            if (isNaN(fontSize) || fontSize < 2 || fontSize > 20) {
                alert('í°íŠ¸ í¬ê¸°ëŠ” 2 ~ 20 ì‚¬ì´ì˜ ì •ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.');
                return;
            }
            if (!asciiChars || asciiChars.length < 2) {
                alert('ASCII ë¬¸ìì…‹ì€ ìµœì†Œ 2ê°œ ì´ìƒ ì…ë ¥í•˜ì„¸ìš”.');
                return;
            }

            const width = Math.floor(sourceImage.width * scale);
            const height = Math.floor(sourceImage.height * scale);

            // í¬ê¸°ì— ë§ì¶° ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
            canvas.width = asciiCanvas.width = width;
            canvas.height = asciiCanvas.height = height;

            // ì›ë³¸ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
            ctx.clearRect(0, 0, width, height);
            ctx.drawImage(sourceImage, 0, 0);

            // ASCII ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
            asciiCtx.clearRect(0, 0, width, height);
            asciiCtx.fillStyle = 'black';
            asciiCtx.font = `${fontSize}px Consolas, monospace`;
            asciiCtx.textBaseline = 'top';

            // ìº”ë²„ìŠ¤ í¬ê¸°ì— ë§ëŠ” í”½ì…€ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
            const imageData = ctx.getImageData(0, 0, width, height).data;
            
            // ì´ˆê¸°í™”
            asciiImage = '';

            for (let y = 0; y < height; y += gap) {
            let line = '';
            for (let x = 0; x < width; x += gap) {
                const index = (y * width + x) * 4;
                const r = imageData[index];
                const g = imageData[index + 1];
                const b = imageData[index + 2];
                const gray = 0.299 * r + 0.587 * g + 0.114 * b;

                const charIndex = Math.min(asciiChars.length - 1, Math.floor(gray / (256 / asciiChars.length)));
                const char = getCharSafe(asciiChars, charIndex);
                line += char;

                asciiCtx.fillText(char, x, y);
            }
            asciiImage += line + '\n';
            }
            // í•œ ë²ˆì— DOMì— ë°˜ì˜
            output.innerText = asciiImage;
        }

        // GIF ì• ë‹ˆë©”ì´ì…˜ ASCII ë³€í™˜ í•¨ìˆ˜ (í”„ë ˆì„ ì´ë¯¸ì§€ ë°›ì•„ì„œ ASCII ë³€í™˜)
        function drawFrameAndGenerateASCII(canvasFrame) {
            generateASCIIFromImage(canvasFrame);
        }

        function animateGIF(frames, width, height) {
            if (animationTimer) clearTimeout(animationTimer);

            const frame = frames[animationIndex];
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');

            // í”„ë ˆì„ ì´ë¯¸ì§€ ë°ì´í„° ìƒì„±
            const imageData = tempCtx.createImageData(frame.dims.width, frame.dims.height);
            imageData.data.set(frame.patch);
            tempCtx.putImageData(imageData, frame.dims.left, frame.dims.top);

            // ì™„ì„±ëœ ìº”ë²„ìŠ¤ë¥¼ ì´ìš©í•´ ASCII ë³€í™˜
            drawFrameAndGenerateASCII(tempCanvas);

            animationIndex = (animationIndex + 1) % frames.length;

            // delayê°€ 0ì´ë©´ ê¸°ë³¸ 100msë¡œ ì²˜ë¦¬
            const delay = frame.delay > 0 ? frame.delay * 10 : 100;
            animationTimer = setTimeout(() => animateGIF(frames, width, height), delay);
        }

        // ì´ë¯¸ì§€ ë¡œë“œ ì´ë²¤íŠ¸
        currentImg.onload = () => {
            canvas.style.border = '1px solid gray';
            generateASCIIFromImage(currentImg);
        };

        currentImg.onerror = () => {
            canvas.style.border = 'none';
            if (!currentImg.src) {
                alert('ì´ë¯¸ì§€ ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. íŒŒì¼ ê²½ë¡œë‚˜ ë„¤íŠ¸ì›Œí¬ ìƒíƒœë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.');
            }
        };


        generateBtn.addEventListener('click', () => {
            if (animationFrames) {
                // GIF ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì´ë©´ ì¬ìƒ ìœ ì§€
                animateGIF(animationFrames, canvas.width, canvas.height);
            } else {
                generateASCIIFromImage(currentImg);
            }
        });

        function handleFile(file) {
            console.log("handleFile called, file:", file);
            if (!file || !file.type.startsWith('image/')) {
                alert('ì´ë¯¸ì§€ íŒŒì¼ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.');
                return;
            }

            const reader = new FileReader();

            // GIF ì²˜ë¦¬
            if (file.type === 'image/gif') {
                reader.onload = e => {
                    const buffer = e.target.result;
                    const gif = parseGIF(buffer);
                    const frames = decompressFrames(gif, true);

                    // ì „ì²´ ìº”ë²„ìŠ¤ í¬ê¸° - GIF ì „ì²´ í¬ê¸° ê¸°ì¤€
                    const gifWidth = gif.lsd.width;
                    const gifHeight = gif.lsd.height;

                    animationFrames = frames;
                    animationIndex = 0;

                    // ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
                    animateGIF(animationFrames, gifWidth, gifHeight);
                };
                reader.readAsArrayBuffer(file);
            } else {
                // ì¼ë°˜ ì´ë¯¸ì§€
                reader.onload = e => {
                    if (animationTimer) clearTimeout(animationTimer);
                    animationFrames = null;
                    animationIndex = 0;

                    const newImg = new Image();
                    newImg.onload = () => {
                        currentImg = newImg;
                        generateASCIIFromImage(currentImg);
                    };
                    newImg.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        // ë¹„ìœ¨ë³´ì • í•¨ìˆ˜
        function aspectFix(charWidth, lineHeight){
            const doFix = aspectFixCheckbox.checked;
            const ratioFix = Math.max(lineHeight, charWidth) / Math.min(lineHeight, charWidth);
            const isWidthSmaller = charWidth < lineHeight;

            const aspectFixX = doFix && isWidthSmaller ? ratioFix : 1;
            const aspectFixY = doFix && !isWidthSmaller ? ratioFix : 1;
            
            return [aspectFixX, aspectFixY]
        }

        // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ê¸°ëŠ¥ ì¶”ê°€
        dropArea.addEventListener('dragover', e => {
            e.preventDefault();
            dropArea.style.background = '#f8f8f8';
        });

        dropArea.addEventListener('dragleave', () => {
            dropArea.style.background = '';
        });

        dropArea.addEventListener('drop', e => {
            e.preventDefault();
            dropArea.style.background = '';
            const file = e.dataTransfer.files[0];
            handleFile(file);
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            handleFile(file);
        });

        // dropArea í´ë¦­ ì‹œ fileInput í´ë¦­
        dropArea.addEventListener('click', () => {
            fileInput.click();
        });


        // ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ í´ë¦­ ì‹œ íŒŒì¼ ìƒì„± ë° ë‹¤ìš´ë¡œë“œ
        // TXT ì €ì¥ ë²„íŠ¼
        downloadTxtBtn.addEventListener('click', () => {
            let fileName = prompt("ì €ì¥í•  íŒŒì¼ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš” (í™•ì¥ì ì—†ì´):", "ascii-art");
            if (!fileName) return;
            
            // íŒŒì¼ëª…ì—ì„œ í—ˆìš©í•˜ì§€ ì•ŠëŠ” ë¬¸ìë¥¼ '_'ë¡œ ë³€ê²½
            fileName = fileName.replace(/[\\/:*?"<>|]/g, '_');

            if (!fileName.toLowerCase().endsWith('.txt')) fileName += '.txt';
            
            const blob = new Blob([asciiImage], { type: 'text/plain' });
            if (!blob) {
                alert('ë‹¤ìš´ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
                return;
            }
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            URL.revokeObjectURL(url);
        });
        // PNG ì €ì¥ ë²„íŠ¼
        downloadPngBtn.addEventListener('click', () => {
            const baseFontSize = parseInt(fontSizeInput.value);
            const lines = asciiImage.split('\n');
            const cols = lines[0]?.length || 0;

            const scaleFactor = parseInt(resolutionSelect.value);

            const fontSize = baseFontSize * scaleFactor;

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.font = `${fontSize}px Consolas, monospace`;

            const asciiChars = asciiInput.value;

            //const sampleMetrics = tempCtx.measureText('ã€€'); // U+3000

            // ê°€ì¥ ë„“ì€ ë¬¸ì ì°¾ì•„ì„œ í¬ê¸° ì¸¡ì •
            let maxWidth = 0;
            let maxAscent = 0;
            let maxDescent = 0;
            for (const ch of asciiChars) {
                const metrics = tempCtx.measureText(ch);
                if (metrics.width > maxWidth) maxWidth = metrics.width;
                if (metrics.actualBoundingBoxAscent > maxAscent) maxAscent = metrics.actualBoundingBoxAscent || 0;
                if (metrics.actualBoundingBoxDescent > maxDescent) maxDescent = metrics.actualBoundingBoxDescent || 0;
            }
            
            const charWidth = maxWidth;
            const lineHeight = maxAscent + maxDescent || fontSize;

            // ë¹„ìœ¨ë³´ì •
            const [aspectFixX, aspectFixY] = aspectFix(charWidth, lineHeight)
            
            //ìœ ë™ì ì¸ ì§¤ë¦¼ë°©ì§€ padding ê³„ì‚°(30%)
            const horizontalPadding = Math.ceil(charWidth * 0.3);
            const verticalPadding = Math.ceil(lineHeight * 0.3);

            const width = Math.ceil(cols * charWidth * aspectFixX + horizontalPadding * 2);
            const height = Math.ceil(lines.length * lineHeight * aspectFixY + verticalPadding * 2);

            tempCanvas.width = width;
            tempCanvas.height = height;
            
            const isTransparent = transparentBgCheckbox.checked;
            
            if (!isTransparent) {
                // ë°°ê²½ í°ìƒ‰ ì±„ìš°ê¸°
                tempCtx.fillStyle = 'white';
                tempCtx.fillRect(0, 0, width, height);
            } else {
                // íˆ¬ëª… ë°°ê²½ (ê¸°ë³¸ í´ë¦¬ì–´)
                tempCtx.clearRect(0, 0, width, height);
            }

            tempCtx.font = `${fontSize}px Consolas, monospace`;
            tempCtx.fillStyle = 'black';
            tempCtx.textBaseline = 'top';
            tempCtx.textAlign = 'left'; // ì™¼ìª½ ì •ë ¬

            lines.forEach((line, rowIndex) => {
                const x = horizontalPadding;
                const y = verticalPadding + rowIndex * lineHeight * aspectFixY;
                tempCtx.save();
                tempCtx.translate(x, y);
                tempCtx.scale(aspectFixX, aspectFixY);
                tempCtx.fillText(line, 0, 0);
                tempCtx.restore();
            });

            let fileName = prompt("ì €ì¥í•  íŒŒì¼ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš” (í™•ì¥ì ì—†ì´):", "ascii-art");
            if (!fileName) return;
            // íŒŒì¼ëª… ì•ˆì „ ì²˜ë¦¬
            fileName = fileName.replace(/[\\/:*?"<>|]/g, '_');

            if (!fileName.toLowerCase().endsWith('.png')) fileName += '.png';

            // Blobìœ¼ë¡œ ë³€í™˜ í›„ ë‹¤ìš´ë¡œë“œ
            tempCanvas.toBlob(blob => {
                if (!blob) {
                    alert('ë‹¤ìš´ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
                    return;
                }
                const url = URL.createObjectURL(blob);
                // ê²°ê³¼ë¬¼ ìƒˆì°½ì—´ê¸°
                window.open(url, '_blank');

                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                URL.revokeObjectURL(url);
            }, 'image/png');
        });
    </script>

</body>
</html>